<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>ui.lifecycle API documentation</title>
<meta name="description" content="UI lifecycle management for StreamDeck â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ui.lifecycle</code></h1>
</header>
<section id="section-intro">
<p>UI lifecycle management for StreamDeck.</p>
<p>This module handles resource cleanup and graceful shutdown for the jarvis application.
It ensures that system resources are properly released when the application exits,
whether through normal shutdown, interrupt signals, or unexpected crashes.</p>
<p>Key responsibilities:
- Release any "stuck" keyboard keys that might remain pressed
- Close StreamDeck hardware connection cleanly
- Provide graceful shutdown mechanisms
- Prevent resource leaks and hardware conflicts</p>
<p>This module is critical for system stability because ydotool key events
can leave the system in an unusable state if not properly cleaned up.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ui.lifecycle.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>deck=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(deck=None):
    &#34;&#34;&#34;Perform complete application cleanup and resource release.

    This function handles all necessary cleanup operations when jarvis shuts down.
    It&#39;s designed to be safe to call multiple times and from different contexts
    (normal exit, signal handlers, exception handlers).

    Args:
        deck: Optional StreamDeck device object to clean up

    Cleanup Operations:
        1. Release any stuck keyboard keys via ydotool
        2. Reset StreamDeck display (clear all keys)
        3. Close StreamDeck hardware connection
        4. Prevent duplicate cleanup attempts

    Design Principles:
        - **Idempotent**: Safe to call multiple times
        - **Defensive**: Handles errors gracefully
        - **Complete**: Cleans up all acquired resources
        - **Fast**: Minimal delay during shutdown

    Calling Contexts:
        - Registered with atexit for normal Python shutdown
        - Called from signal handlers (Ctrl+C)
        - Called manually in exception handlers
        - Called from reset/recovery scripts

    Note:
        Uses a global flag to prevent duplicate cleanup from multiple triggers.
        Cleanup errors are reported but don&#39;t prevent other cleanup steps.
    &#34;&#34;&#34;
    global clean_stickykeys

    # Check if cleanup has already been performed
    # This prevents duplicate cleanup from multiple triggers
    if clean_stickykeys:
        return  # Exit early - cleanup already done

    # Set flag to prevent future cleanup attempts
    clean_stickykeys = True  # Mark cleanup as performed

    try:
        # Provide user feedback about cleanup process
        print(&#34;\nCleaning up...&#34;)

        # STEP 1: Release any stuck keyboard keys
        # This is the most critical cleanup step because stuck keys
        # can make the entire system unusable
        release_all_keys()

        # STEP 2: Clean up StreamDeck hardware if provided
        if deck and deck.is_open():
            # Clear all key displays (turn off icons/text)
            deck.reset()

            # Close USB connection to StreamDeck
            # This releases the device for other applications
            deck.close()

        # CLEANUP SEQUENCE REASONING:
        # 1. Keys first: Most critical for system usability
        # 2. StreamDeck last: Less critical, mainly cosmetic and resource management

    except Exception as e:
        # DEFENSIVE ERROR HANDLING:
        # Cleanup should never fail completely, even if individual steps fail
        # Report the error but don&#39;t crash or raise exceptions
        # This is especially important in signal handlers and atexit contexts
        print(f&#34;(cleanup ignored error: {e})&#34;)

        # ALTERNATIVE ERROR HANDLING:
        # Could log to file: logging.error(f&#34;Cleanup error: {e}&#34;)
        # Could try partial cleanup: Continue with remaining steps
        # Could notify user differently: GUI notification, system notification
        #
        # Simple console message chosen because:
        # - Cleanup happens during shutdown when logging might not work
        # - User needs immediate feedback about any cleanup issues
        # - Simple approach is most reliable during shutdown scenarios

    # RESOURCE LEAK PREVENTION:
    # Even if exceptions occur:
    # - Flag prevents retry attempts that might make things worse
    # - System-level resources (ydotool) are automatically cleaned up by OS
    # - USB resources are handled by kernel drivers
    # - Python memory is reclaimed by interpreter shutdown</code></pre>
</details>
<div class="desc"><p>Perform complete application cleanup and resource release.</p>
<p>This function handles all necessary cleanup operations when jarvis shuts down.
It's designed to be safe to call multiple times and from different contexts
(normal exit, signal handlers, exception handlers).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>deck</code></strong></dt>
<dd>Optional StreamDeck device object to clean up</dd>
</dl>
<p>Cleanup Operations:
1. Release any stuck keyboard keys via ydotool
2. Reset StreamDeck display (clear all keys)
3. Close StreamDeck hardware connection
4. Prevent duplicate cleanup attempts</p>
<p>Design Principles:
- <strong>Idempotent</strong>: Safe to call multiple times
- <strong>Defensive</strong>: Handles errors gracefully
- <strong>Complete</strong>: Cleans up all acquired resources
- <strong>Fast</strong>: Minimal delay during shutdown</p>
<p>Calling Contexts:
- Registered with atexit for normal Python shutdown
- Called from signal handlers (Ctrl+C)
- Called manually in exception handlers
- Called from reset/recovery scripts</p>
<h2 id="note">Note</h2>
<p>Uses a global flag to prevent duplicate cleanup from multiple triggers.
Cleanup errors are reported but don't prevent other cleanup steps.</p></div>
</dd>
<dt id="ui.lifecycle.initialize_lifecycle"><code class="name flex">
<span>def <span class="ident">initialize_lifecycle</span></span>(<span>ydotool_path, keycodes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_lifecycle(ydotool_path, keycodes):
    &#34;&#34;&#34;Initialize the lifecycle module with required configuration.

    This function sets up the module with the configuration needed for
    cleanup operations. It&#39;s called once during application startup to
    ensure cleanup tools are available for shutdown scenarios.

    Args:
        ydotool_path (str): Path to ydotool executable for key operations
        keycodes (dict): Mapping of key names to Linux input event codes

    Initialization Timing:
        Called early in the startup sequence, after configuration is loaded
        but before StreamDeck operations begin. This ensures cleanup tools
        are available if needed during startup or shutdown.

    Error Handling:
        No validation is performed here because this is called during
        controlled startup with validated config. Invalid configuration
        would be caught during actual cleanup attempts.
    &#34;&#34;&#34;
    # Set module-level configuration variables
    global YDOTOOL_PATH, KEYCODES

    YDOTOOL_PATH = ydotool_path  # Store path to ydotool for key release operations
    KEYCODES = keycodes          # Store keycode mapping for release_all_keys()

    # ALTERNATIVE APPROACHES:
    # 1. Class-based: LifecycleManager(ydotool_path, keycodes)
    # 2. Context manager: with lifecycle_context(ydotool_path, keycodes):
    # 3. Singleton pattern: LifecycleManager.instance().configure(...)
    #
    # Module-level functions chosen for:
    # - Simplicity and directness
    # - Compatibility with atexit.register() usage
    # - Consistent with other jarvis modules</code></pre>
</details>
<div class="desc"><p>Initialize the lifecycle module with required configuration.</p>
<p>This function sets up the module with the configuration needed for
cleanup operations. It's called once during application startup to
ensure cleanup tools are available for shutdown scenarios.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ydotool_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to ydotool executable for key operations</dd>
<dt><strong><code>keycodes</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping of key names to Linux input event codes</dd>
</dl>
<p>Initialization Timing:
Called early in the startup sequence, after configuration is loaded
but before StreamDeck operations begin. This ensures cleanup tools
are available if needed during startup or shutdown.</p>
<p>Error Handling:
No validation is performed here because this is called during
controlled startup with validated config. Invalid configuration
would be caught during actual cleanup attempts.</p></div>
</dd>
<dt id="ui.lifecycle.release_all_keys"><code class="name flex">
<span>def <span class="ident">release_all_keys</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release_all_keys():
    &#34;&#34;&#34;Release all keyboard keys to prevent &#34;sticky key&#34; problems.

    This function sends key release events for all keys defined in KEYCODES
    to ensure no keys remain &#34;stuck&#34; in the pressed state when jarvis exits.
    This is essential because ydotool can leave keys in pressed state if
    the application crashes or exits unexpectedly.

    Sticky Key Problem:
        ydotool sends low-level input events to the Linux kernel. If a key press
        event is sent but the corresponding key release event is never sent
        (due to application crash, kill signal, etc.), the key remains &#34;pressed&#34;
        from the system&#39;s perspective. This can make the system unusable.

    Solution Strategy:
        Send release events (keycode:0) for all possible keys that jarvis might
        have pressed. This is safe because:

        - Releasing an already-released key has no effect
        - Better to release too many keys than leave any stuck
        - The overhead is minimal (small command, runs once at exit)

    Called During:
        - Normal application shutdown (atexit handler)
        - Signal-based shutdown (SIGINT/Ctrl+C handler)
        - Manual cleanup calls
        - Recovery scenarios (reset_jarvis.py)

    Raises:
        RuntimeError: If lifecycle module not initialized

    Note:
        Validates initialization but doesn&#39;t handle ydotool execution errors
        because this is typically called during shutdown when error handling
        options are limited.
    &#34;&#34;&#34;
    # Verify module has been properly initialized
    if YDOTOOL_PATH is None or KEYCODES is None:
        raise RuntimeError(&#34;Lifecycle module not initialized. Call initialize_lifecycle() first.&#34;)

    # Build list of key release events for all known keys
    # Format: &#34;keycode:0&#34; where 0 means &#34;release&#34; (1 would mean &#34;press&#34;)
    release_events = [f&#34;{keycode}:0&#34; for keycode in KEYCODES.values()]

    # Send all key release events in a single ydotool command
    # Using subprocess.Popen() for non-blocking execution
    # We don&#39;t wait for completion because this is cleanup code
    subprocess.Popen(
        [YDOTOOL_PATH, &#34;key&#34;] + release_events
    )

    # PERFORMANCE ANALYSIS:
    # - Number of keys: ~50 keys in KEYCODES
    # - Command size: ~200 characters
    # - Execution time: &lt;10ms typically
    # - Memory usage: Minimal (small subprocess)
    #
    # ALTERNATIVE APPROACHES CONSIDERED:
    # 1. Individual ydotool commands per key: Much slower, more processes
    # 2. Only release &#34;dangerous&#34; modifier keys: Risky, might miss stuck keys
    # 3. System-level key state reset: Complex, platform-specific
    # 4. Virtual keyboard reset: Would require additional dependencies
    #
    # Current approach chosen for balance of safety, performance, and simplicity</code></pre>
</details>
<div class="desc"><p>Release all keyboard keys to prevent "sticky key" problems.</p>
<p>This function sends key release events for all keys defined in KEYCODES
to ensure no keys remain "stuck" in the pressed state when jarvis exits.
This is essential because ydotool can leave keys in pressed state if
the application crashes or exits unexpectedly.</p>
<p>Sticky Key Problem:
ydotool sends low-level input events to the Linux kernel. If a key press
event is sent but the corresponding key release event is never sent
(due to application crash, kill signal, etc.), the key remains "pressed"
from the system's perspective. This can make the system unusable.</p>
<p>Solution Strategy:
Send release events (keycode:0) for all possible keys that jarvis might
have pressed. This is safe because:</p>
<pre><code>- Releasing an already-released key has no effect
- Better to release too many keys than leave any stuck
- The overhead is minimal (small command, runs once at exit)
</code></pre>
<p>Called During:
- Normal application shutdown (atexit handler)
- Signal-based shutdown (SIGINT/Ctrl+C handler)
- Manual cleanup calls
- Recovery scenarios (reset_jarvis.py)</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If lifecycle module not initialized</dd>
</dl>
<h2 id="note">Note</h2>
<p>Validates initialization but doesn't handle ydotool execution errors
because this is typically called during shutdown when error handling
options are limited.</p></div>
</dd>
<dt id="ui.lifecycle.safe_exit"><code class="name flex">
<span>def <span class="ident">safe_exit</span></span>(<span>deck=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe_exit(deck=None):
    &#34;&#34;&#34;Perform cleanup and exit the application gracefully.

    This function provides a single point for graceful application shutdown.
    It ensures all cleanup operations are performed before terminating the
    Python process.

    Args:
        deck: Optional StreamDeck device object to clean up before exit

    Exit Code:
        Uses exit code 0 to indicate successful/intentional shutdown.
        This is important for:

        - System service management (systemd, etc.)
        - Process monitoring tools
        - Shell scripts that check exit codes
        - Automated restart logic

    Usage Contexts:
        - Signal handlers (Ctrl+C interrupt)
        - Error recovery after unrecoverable errors
        - Manual shutdown commands
        - Graceful restart scenarios

    Shutdown Sequence:
        1. Run complete cleanup (release keys, close hardware)
        2. Exit Python interpreter with success code
        3. OS reclaims any remaining resources

    Note:
        This function does not return - it terminates the Python process.
    &#34;&#34;&#34;
    # Perform all necessary cleanup operations
    # This includes key release and StreamDeck hardware cleanup
    cleanup(deck)

    # Exit Python interpreter with success code (0)
    # sys.exit(0) is preferred over sys.exit() because:
    # - Explicit success code for clarity
    # - Consistent behavior across different Python versions
    # - Clear intent that this is intentional, successful shutdown
    sys.exit(0)

    # ALTERNATIVE EXIT METHODS:
    # - sys.exit(): Uses default code (None, treated as 0)
    # - sys.exit(1): Error exit code (for unexpected shutdowns)
    # - os._exit(0): Immediate exit without cleanup (dangerous)
    # - quit(): Interactive interpreter only (not for scripts)
    # - exit(): Interactive interpreter only (not for scripts)
    #
    # sys.exit(0) chosen because:
    # - Allows Python cleanup and atexit handlers to run
    # - Clear success indication
    # - Standard practice for graceful shutdown

    # POST-EXIT BEHAVIOR:
    # After sys.exit(0):
    # 1. Python runs any remaining atexit handlers (including our cleanup)
    # 2. Python interpreter shuts down cleanly
    # 3. OS reclaims process resources (memory, file handles, etc.)
    # 4. Parent process (shell, systemd) receives exit code 0
    # 5. StreamDeck hardware remains in last known state until next connection</code></pre>
</details>
<div class="desc"><p>Perform cleanup and exit the application gracefully.</p>
<p>This function provides a single point for graceful application shutdown.
It ensures all cleanup operations are performed before terminating the
Python process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>deck</code></strong></dt>
<dd>Optional StreamDeck device object to clean up before exit</dd>
</dl>
<p>Exit Code:
Uses exit code 0 to indicate successful/intentional shutdown.
This is important for:</p>
<pre><code>- System service management (systemd, etc.)
- Process monitoring tools
- Shell scripts that check exit codes
- Automated restart logic
</code></pre>
<p>Usage Contexts:
- Signal handlers (Ctrl+C interrupt)
- Error recovery after unrecoverable errors
- Manual shutdown commands
- Graceful restart scenarios</p>
<p>Shutdown Sequence:
1. Run complete cleanup (release keys, close hardware)
2. Exit Python interpreter with success code
3. OS reclaims any remaining resources</p>
<h2 id="note">Note</h2>
<p>This function does not return - it terminates the Python process.</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ui" href="index.html">ui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ui.lifecycle.cleanup" href="#ui.lifecycle.cleanup">cleanup</a></code></li>
<li><code><a title="ui.lifecycle.initialize_lifecycle" href="#ui.lifecycle.initialize_lifecycle">initialize_lifecycle</a></code></li>
<li><code><a title="ui.lifecycle.release_all_keys" href="#ui.lifecycle.release_all_keys">release_all_keys</a></code></li>
<li><code><a title="ui.lifecycle.safe_exit" href="#ui.lifecycle.safe_exit">safe_exit</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
