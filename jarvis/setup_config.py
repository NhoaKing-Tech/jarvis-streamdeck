#!/usr/bin/env python3
"""
Setup script to create personalized configuration for Jarvis StreamDeck.

This script provides an interactive configuration wizard that helps users
set up their jarvis environment by creating a personalized config.env file.
It handles path detection, user prompts, and configuration file generation.

Purpose:
- Simplify initial jarvis setup for new users
- Generate properly formatted configuration files
- Detect system-specific paths and tools
- Prevent common configuration errors

Usage:
    python setup_config.py

Output:
    Creates config.env file with user-specific configuration
"""

# Standard library imports for file and path operations
from pathlib import Path  # Modern path handling, more robust than os.path

def create_config() -> None:
    """Create a personalized config.env file through interactive prompts.

    This function implements an interactive configuration wizard that guides
    users through setting up their jarvis environment. It provides intelligent
    defaults, validates input, and generates a properly formatted configuration file.

    Process:
        1. Checks for existing configuration and asks about overwriting
        2. Provides intelligent defaults based on system detection
        3. Prompts user for key configuration values
        4. Generates properly formatted config.env file
        5. Provides usage instructions

    Configuration Strategy:
        - Uses sensible defaults that work for most users
        - Allows empty input to accept defaults (user-friendly)
        - Validates critical paths where possible
        - Generates self-documenting configuration file

    Error Handling:
        - Checks for existing config files to prevent accidental overwrites
        - Handles file write permissions gracefully
        - Provides clear feedback and instructions

    Generated Configuration:
        Creates config.env with paths for ydotool, projects directory,
        and Obsidian vaults, plus comments for additional options.
    """
    # Determine path for configuration file (same directory as this script)
    config_path = Path(__file__).parent / "config.env"

    # EXISTING FILE HANDLING:
    # Check if configuration already exists and get user permission to overwrite
    if config_path.exists():
        response = input("File config.env already exists. Overwrite? (y/N): ")
        if response.lower() != 'y':
            print("Past configuration not overwritten.")
            return  # Exit early without making changes

    # SETUP PROCESS INTRODUCTION:
    # Provide clear information about what the setup process will do
    print("Creating Jarvis StreamDeck configuration...")
    print("Press Enter to use default path values")
    print("")

    # SYSTEM DETECTION:
    # Get current user's home directory for generating intelligent defaults
    home = Path.home()  # More reliable than os.path.expanduser('~')

    # INTERACTIVE CONFIGURATION COLLECTION:
    # Prompt for each configuration value with intelligent defaults

    # ydotool path configuration
    # Detect system ydotool installation and offer as default
    default_ydotool = which_ydotool()  # Use helper function to find ydotool
    ydotool_input = input(f"ydotool path [{default_ydotool}]: ")
    ydotool_path = ydotool_input.strip() or default_ydotool  # Use default if empty

    # Projects directory configuration
    # Default to ~/projects (common convention) but allow customization
    default_projects = home / 'projects'
    projects_input = input(f"projects directory [{default_projects}]: ")
    projects_dir = projects_input.strip() or str(default_projects)

    # Obsidian vault configuration
    # Default to a vault within the projects directory
    default_vault = f"{projects_dir}/my_vault"
    obsidian_input = input(f"Obsidian vault [{default_vault}]: ")
    obsidian_vault = obsidian_input.strip() or default_vault

    # CONFIGURATION FILE GENERATION:
    # Create properly formatted config.env file with collected values
    config_content = f"""# Jarvis StreamDeck System Configuration
# Generated by setup_config.py interactive configuration wizard
# Modify these values to customize jarvis behavior

# Path to ydotool executable for keyboard input simulation
YDOTOOL_PATH={ydotool_path}

# Directory containing your code projects
PROJECTS_DIR={projects_dir}

# Primary Obsidian vault path
OBSIDIAN_VAULT={obsidian_vault}

# Additional configuration options:
# KEYRING_PW=your_password_here
# OBSIDIAN_VAULT_JOURNAL=/path/to/journal/vault
# OBSIDIAN_VAULT_NOTES=/path/to/notes/vault
"""

    # CONFIGURATION FILE WRITING:
    try:
        with open(config_path, 'w', encoding='utf-8') as f:
            f.write(config_content)
    except IOError as e:
        print(f"Error writing configuration file: {e}")
        print("Please check file permissions and try again.")
        return

    # SUCCESS FEEDBACK AND USAGE INSTRUCTIONS:
    print(f"\nâœ… Configuration saved to {config_path}")
    print("\nTo use this configuration:")
    print("\n1. Direct execution:")
    print("   source config.env && python run_jarvis.py")
    print("\n2. System service setup:")
    print("   See config_example.env for systemd service configuration")
    print("\n3. Manual environment setup:")
    print("   export $(cat config.env | xargs) && python run_jarvis.py")

    # NEXT STEPS GUIDANCE:
    print("\nNext steps:")
    print("1. Test the configuration: python run_jarvis.py")
    print("2. Customize layouts in ui/render.py if needed")
    print("3. Add custom icons to assets/jarvisicons/")
    print("4. Create code snippets in assets/snippets/")

def which_ydotool() -> str:
    """Find ydotool executable in system PATH with intelligent fallbacks.

    This function attempts to locate the ydotool executable using multiple
    strategies to handle different installation methods and system configurations.

    Returns:
        str: Path to ydotool executable, or a reasonable fallback

    Detection Strategy:
        1. Check system PATH using shutil.which()
        2. Fall back to common installation locations
        3. Provide user-friendly default that can be manually corrected

    Installation Methods Supported:
        - Package manager installation (apt, yum, pacman, etc.)
        - Manual compilation and installation
        - Local user installation
        - Custom installation paths

    Fallback Locations:
        - /usr/local/bin/ydotool (manual compilation default)
        - /usr/bin/ydotool (package manager installation)
        - /opt/ydotool/bin/ydotool (custom installation)
        - ~/.local/bin/ydotool (user-local installation)

    Note:
        If no ydotool installation is found, returns a reasonable default
        path that the user can correct during the interactive setup.
    """
    # Standard library import for executable detection
    import shutil

    # PRIMARY DETECTION: Use shutil.which() to search system PATH
    # This handles most standard installations where ydotool is in PATH
    detected_path = shutil.which('ydotool')

    if detected_path:
        # Found ydotool in system PATH - this is the most reliable result
        return detected_path

    # FALLBACK DETECTION: Common installation locations
    # If ydotool isn't in PATH, check common installation directories
    common_locations = [
        '/usr/local/bin/ydotool',  # Manual compilation default
        '/usr/bin/ydotool',        # Package manager installation
        '/opt/ydotool/bin/ydotool', # Custom installation location
        f'{Path.home()}/.local/bin/ydotool',  # User-local installation
    ]

    for location in common_locations:
        if Path(location).exists() and Path(location).is_file():
            return location

    # FINAL FALLBACK: Reasonable default that user can correct if needed
    # This provides a starting point even if auto-detection fails
    return '/usr/local/bin/ydotool'

    # ALTERNATIVE DETECTION METHODS CONSIDERED:
    # 1. which command: subprocess.run(['which', 'ydotool'])
    #    - Less portable, depends on 'which' being available
    # 2. locate command: subprocess.run(['locate', 'ydotool'])
    #    - Requires updatedb, may be outdated
    # 3. find command: subprocess.run(['find', '/', '-name', 'ydotool'])
    #    - Very slow, requires root access for full filesystem search
    #
    # shutil.which() chosen because:
    # - Built into Python standard library
    # - Respects PATH environment variable
    # - Cross-platform compatible
    # - Fast and reliable

if __name__ == "__main__":
    """Script entry point for interactive configuration setup.

    This ensures the configuration wizard only runs when script is executed
    directly, not when imported as a module by other Python scripts.

    Execution Flow:
        1. Script is run from command line: python setup_config.py
        2. Interactive configuration wizard starts
        3. User provides configuration values
        4. config.env file is generated
        5. Usage instructions are displayed

    Post-Execution:
        After this script completes:
        - config.env file exists with user configuration
        - User can run jarvis with: source config.env && python run_jarvis.py
        - System service can be configured using the generated config
    """
    create_config()

    # POST-EXECUTION:
    # After this script completes:
    # - config.env file exists with user configuration
    # - User can run jarvis with: source config.env && python run_jarvis.py
    # - System service can be configured using the generated config
    #
    # ALTERNATIVE EXECUTION METHODS:
    # - python -m jarvis.setup_config (if jarvis is in PYTHONPATH)
    # - Direct execution: ./setup_config.py (requires shebang and execute permission)
    # - IDE execution: Run from development environment