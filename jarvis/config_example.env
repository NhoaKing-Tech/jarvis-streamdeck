# Jarvis System Configuration (EXAMPLE)
    # Output environment configuration file created by executing
    # setup_config.py in the jarvis directory.

    YDOTOOL_PATH=/home/username/ydotool/build/ydotool
    PROJECTS_DIR=/home/username/projects
    OBSIDIAN_VAULT_journal=/home/username/projects/journal_vault
    OBSIDIAN_VAULT_quartz=/home/username/projects/quartz_vault
    KEYRING_PW=1234

---
# USAGE

# When executing setup_config.py you will create a similar file to this one, without the comments
# From the terminal you will be prompted to introduce paths.
# The content above usage is only an example of what you would get as a result.

# 1. Path to ydotool executable:

# If you want to be able to execute hotkeys/shortcuts from your streamdeck,
# you need to install ydotool from source and set up a udev rule and a service 
# so that it always running. The ydotool system service content is given at the end
# of this file. 
# Afte building from source the path should look something like:
# YDOTOOL_PATH=/home/yourusername/ydotool/build/ydotool

# 1.1. Basic Build Process

# Update and install dependencies (Ubuntu/Debian):
# `sudo apt update`
# `sudo apt upgrade`
# `sudo apt install git cmake build-essential libevdev-dev scdoc`

# Clone and build:
# `git clone https://github.com/ReimuNotMoe/ydotool.git`
# `cd ydotool`
# `mkdir build`
# `cd build`
# `cmake ..`
# `make -j $(nproc)`

# 1.2. udev rule for ydotool:

# You need to set up a ydotool udev rule in /etc/udev/rules.d
# The name of the rule should be something like '99-uinput.rules'.
# The content should be:

# ======================
# YDOTOOL UDEV RULE
# ======================
# KERNEL=="uinput", MODE="0660", GROUP="uinput", OPTIONS+="static_node=uinput"
# ======================

# 1.3. Set up a service so that ydotool is always running. Set this service called
# 'ydotoold.service' in /home/username/.config/systemd/user. If the ydotool build is
# is /home/yourusername/ydotool/build/ydotool, the content should be:

# ======================
# YDOTOOL SERVICE CONFIG
# ======================

# [Install]
# WantedBy=default.target

# [Unit]
# Description=ydotoold daemon (Wayland key injection)

# [Service]
# ExecStart=/home/nhoaking/ydotool/build/ydotoold
# Restart=always

# [Install]
# WantedBy=default.target

# ======================

# We could have used ydotool instead of ydotool, since jarvis runs on X11, but the decision
# of using X11 was taken after the initial work on Jarvis, which was done running Wayland.
# When changing to X11, ydotool was tested and since it worked just fine, the change to xdotool
# was not needed since it seemed unnecessary. Furthermore, I do not discard the possibility of
# working more on Jarvis to run it within Wayland, but this needs more experience and knowledge
# than what I currently have, so for now I will stay with X11 for simplicity.

# 2. Give the directory to your projects (default: ~/projects)
# PROJECTS_DIR=/home/yourusername/projects

# 3. Obsidian vault path to journal vault (kind of like a general vault)
OBSIDIAN_VAULT=/home/yourusername/projects/MyVault

# 4. Obsidian vault path to documentation vault used for quartz (in my case). If you wish you
# can simply use this prompt for a different vault or just set it to nothing. You can manually
# edit the config.env file generated with the setup_config.py to delete this variable or even both
# of the obsidian vault paths. In render.py is where you will control in any case if you use the
# obsidian vault paths for opening a vault in obsidian using a codename for each vault. If you do not use
# the action for opening a vault, you can keep the obsidian paths empty.

# 4. Write your password or keyring:
# In the script you get already the warning about this feature, but it is repeated here anyway:
# SECURITY NOTE: This note is about storing passwords in plain text file storage.
# Jarvis handles passwords securely in memory and will not log or expose them unless you share them.
# Storing passwords in plain text files creates security risks:
# - File system access by other users or processes
# - Inclusion in system backups (local or cloud)
# - Accidental sharing or version control commits
# Treat this file with the same care as any sensitive credential.
# Consider using password managers or SSH keys for better security.
-----

# STREAM DECK AND JARVIS LAYER SET UP

# The main.py script can be executed from a default terminal in linux while you test it and customize it.
# I recommend to set up a virtual environment, so that you can install other modules you may want to use in actions for your
# stream deck.

# 1. Python Environment Setup:
# Create and activate a virtual environment:
# `python -m venv jarvis-env`
# `source jarvis-env/bin/activate`

# Install system dependencies for HID device access:
# `sudo apt install libhidapi-libusb0 libhidapi-hidraw0`

# Install additional system dependencies required by jarvis actions:
# `sudo apt install wmctrl playerctl alsa-utils nautilus gnome-terminal xdg-utils`
# - wmctrl: Window management for obsidian/nautilus smart window handling
# - playerctl: Media player control for Spotify integration
# - alsa-utils: Audio mixer control for microphone toggle (provides amixer)
# - nautilus: GNOME file manager for directory navigation
# - gnome-terminal: Terminal emulator for bash script execution
# - xdg-utils: Desktop integration utilities (provides xdg-open)
# Note: procps (provides pgrep) is usually pre-installed on most systems

# Install applications that jarvis can control (optional, install as needed):
# - Visual Studio Code: Download from https://code.visualstudio.com/ or use snap/apt
# - Spotify: `sudo snap install spotify` or download from https://www.spotify.com/
# - Obsidian: Download from https://obsidian.md/ (if using vault functions)

# Install the jarvis-streamdeck package in development mode from the jarvis-streamdeck directory:
# `pip install -e .`
# This creates an "editable install" or "egg-link" that links the installed package
# directly to your source code directory. Changes to the source code are immediately
# reflected without reinstalling. The -e flag creates a .egg-link file in site-packages
# that points to your development directory.

# Install additional Python dependencies:
# `pip install "pillow>=9.0.0"` as according to the forked repo requirements.txt
# `pip install hidapi`

# 2. User Group Setup:
# Add your user to the uinput group (required for ydotool):
# `sudo usermod -a -G uinput $USER`
# Log out and log back in for group changes to take effect.

# However, you need to set up at least a udev rule (as for ydotool built from source),
# to be able to access the stream deck without root permissions each time. To set up the udev rule for
# your stream deck go again to /etc/udev/rules.d and create a new rule called '60-jarvis.rules'. The content
# of that rule should be as follows:

# ======================
# STREAM DECK UDEV RULE CONFIG
# ======================
# SUBSYSTEM=="usb", ATTR{idVendor}=="0fd9", ATTR{idProduct}=="008f", MODE="0666"
# ======================

# If you have another stream deck the idVendor and idProduct will be different.
# Once the stream deck is connected through USB to your machine, simply run in the terminal:
# `lsusb`. This will list the usb devices connected, and you can look for the stream deck device. 

# In any case I prefer to test the script restarting the service instead of executing the main.py from terminal
# To set up the service so that the jarvis layer for stream deck is always running, set a new service called
# 'jarvis.service'. The content should be as follows (replace the paths for your system):

# =========================
# JARVIS SERVICE CONFIG
# =========================
# [Unit]
# Description=Jarvis Service
# After=graphical.target

# [Service]
# Type=simple
# EnvironmentFile=/home/yourusername/your_projects_folder/jarvis-streamdeck/jarvis/config.env
# WorkingDirectory=/home/yourusername/your_projects_folder/jarvis-streamdeck/jarvis
# ExecStartPre=/bin/sleep 10
# ExecStart=/home/yourusername/your_projects_folder/jarvis-streamdeck/jarvis/main.sh
# Restart=on-failure
# =========================

# 3. File Permissions:
# Make the main.sh script executable (user only for security):
# `chmod u+x /home/yourusername/your_projects_folder/jarvis-streamdeck/jarvis/main.sh`

You also need a udev rule for jarvis.service. I called it '99.jarvis-autostart.rules' with the following content:

# =========================
# JARVIS UDEV RULE CONFIG
# =========================
# ACTION=="add", SUBSYSTEM=="usb", ATTR{idVendor}=="0fd9", ATTR{idProduct}=="008f", TAG+="systemd", ENV{SYSTEMD_USER_WANTS}+="jarvis.service"
# ACTION=="remove", SUBSYSTEM=="usb", ATTR{idVendor}=="0fd9", ATTR{idProduct}=="008f", TAG+="systemd", ENV{SYSTEMD_USER_STOP}+="jarvis.service"
# =========================

# After all of these udev and services are set, you need to reload the udev rules, 
# and enable the new services, so that they always run at startup of your machine.

# After the udev rules and the service is set up we need to execute in terminal:
# 
# For the udev rules:
# `sudo udevadm control --reload-rules`
# `sudo udevadm trigger`
#
# For the jarvis service
# `systemctl --user daemon-reload`
# `systemctl --user enable jarvis.service`
# `systemctl --user start jarvis.service`
# `systemctl --user status jarvis.service`
# `journalctl --user -u jarvis.service -f`
# 
# If I make changes to the script controlling my stream deck, I simply need to:
# `systemctl --user restart jarvis.service 
# 
# If I want to stop the service momentarily I can do:
# 
# `systemctl --user stop jarvis.service
# 
# When I want to relaunch it I just need to:
# 
# `systemctl --user start jarvis.service
# 
# This last two commands serve to toggle on/off. It will not affect the service at start up.
# 
# As a result of all of this I got:
# 
# - The **permissions rule** (`60-jarvis.rules`) to avoid needing `sudo`.
# - The **auto-start rule** (`99-jarvis-autostart.rules`) to link the device to `jarvis.service`.
# - The **systemd service** (`jarvis.service`) to manage Jarvis with auto-restart and from my environment setup.

# VERIFICATION STEPS:
# Test each component before proceeding to the next:
#
# 1. Test ydotool installation:
# `~/ydotool/build/ydotool type "hello world"`
#
# 2. Test Stream Deck detection:
# `lsusb | grep -i elgato`
#
# 3. Test Python environment:
# `source jarvis-env/bin/activate && python -c "import hidapi; print('HID access OK')"`
#
# 4. Test jarvis script manually:
# `source jarvis-env/bin/activate && python main.py`
#
# 5. Test service status:
# `systemctl --user status jarvis.service`

# TROUBLESHOOTING:
#
# Common issues and solutions:
#
# - "Permission denied" errors:
#   - Make sure all scripts have executable permissions
#   - Ensure user is in uinput group: `groups $USER | grep uinput`
#   - Check udev rules are loaded: `sudo udevadm control --reload-rules && sudo udevadm trigger`
#   - Verify file permissions: `ls -la main.sh`
#
# - Service fails to start:
#   - Check logs: `journalctl --user -u jarvis.service -n 50`
#   - Verify paths in service file match your system
#   - Test script manually first (use native terminal, not VSCode!!! Environment differs!!)
#
# - Stream Deck not detected:
#   - Check USB connection: `lsusb`
#   - Verify correct idVendor/idProduct in udev rules
#   - Try different USB port
#
# - ydotool not working:
#   - Check if ydotoold service is running: `systemctl --user status ydotoold`
#   - Test manually: `~/ydotool/build/ydotool type "test"`
#   - Verify udev rule for uinput device
#
# - Button configuration:
#   - Modify actions in the render.py file
#   - Each button can be customized with different commands/scripts
#   - Restart jarvis service after changes: `systemctl --user restart jarvis.service`

# NOTES:
# - The numbers of udev rules like 60,99... are intentional. udev rules are proceseed in order, and higher numbers
# run later, so this ensures the order would be the correct one for ydotool and the usb device.

